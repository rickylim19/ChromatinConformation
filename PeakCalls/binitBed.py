#!/usr/bin/env python
# -*- coding:utf-8 -*-


##########################################################################################
# Bam file was generated from bowtie2 sam processed into bam format                      #
# Bin the alignment file generated by bedtools bamtobed -i <file>.bam <file>.bed         #
# Bin's index is the alignment coordinate/bin size                                       #
# Assembly used by default is hg19 in a dict form                                        #
##########################################################################################

#default dict use for counting
from collections import defaultdict

#for I/O and commandline parsing
import os
import sys
import argparse
from argparse import RawTextHelpFormatter
import glob
import gc
import errno

# for threading jobs
import multiprocessing
import Queue

# default assembly: hg19 reference genome
# key:chr and value: size
limits_hg19 = {
   'chr1': 249250621,
   'chr2': 243199373,
   'chr3': 198022430,
   'chr4': 191154276,
   'chr5': 180915260,
   'chr6': 171115067,
   'chr7': 159138663,
   'chr8': 146364022,
   'chr9': 141213431,
   'chr10': 135534747,
   'chr11': 135006516,
   'chr12': 133851895,
   'chr13': 115169878,
   'chr14': 107349540,
   'chr15': 102531392,
   'chr16': 90354753,
   'chr17': 81195210,
   'chr18': 78077248,
   'chr19': 59128983,
   'chr20': 63025520,
   'chr21': 48129895,
   'chr22': 51304566,
   'chrX': 155270560,
   'chrY': 59373566,
}

limits_mm10 = {
    'chr1': 195471971,
    'chr2': 182113224,
    'chr3': 160039680,
    'chr4': 156508116,
    'chr5': 151834684,
    'chr6': 149736546,
    'chr7': 145441459,
    'chr8': 129401213,
    'chr9': 124595110,
    'chr10': 130694993,
    'chr11': 122082543,
    'chr12': 120129022,
    'chr13': 120421639,
    'chr14': 124902244,
    'chr15': 104043685,
    'chr16': 98207768,
    'chr17': 94987271,
    'chr18': 90702639,
    'chr19': 61431566,
    'chrX': 171031299,
    'chrY': 91744698,
}

def binit(bin_size, input_file, format='sam', limits = 'hg19', output_dir='.'):
   """binning the coordinate of the alignment"""

   # key: (chromosome, bin index)
   # value: no of reads
   freq_table = defaultdict(int)

   if format == 'bed':
      chrom_field = 0
      start_field = 1
   else:
      # Default sam format
      chrom_field = 2
      start_field = 3

   if limits == 'hg19':
       limits = limits_hg19
   if limits == 'mm10':
       limits = limits_mm10

   try:
      with open(input_file, 'r') as in_f:
         for line in in_f:
            header=line[0]
            if header == "@":
               continue
            else:
               items = line.split('\t')
               #bin only chromosomes that are in the dict_hg19
               if items[start_field] != '*' and items[chrom_field] in limits:
                  freq_table[(items[chrom_field], int(items[start_field])/bin_size)] += 1
               else:
                  continue

   except IndexError:
      sys.stderr.write("Check if your file is properly formatted, !field separator is a tab!")
   except:
      sys.stderr.write('file error:%s'%(in_f.name))
      raise


   #collect all the aligned chromosome without duplicates 
   chroms = set([chrom for (chrom,bin) in freq_table.keys()])

   #start binning ...

   # remove the garbage collector during list append
   gc.disable()

   bin_list=[]
   for chrom in sorted(limits):
      chrom_size = int(limits[chrom])
      maxbin = int(chrom_size/bin_size)
      for bin in xrange(maxbin):
         bin_list.append("%s\t%s\t%s\t%d\n" % \
                     (chrom, 1+bin*bin_size,
                           (1+bin)*bin_size, freq_table[(chrom,bin)]))

   gc.enable()

   #finally output the file                                     
   if not os.path.exists(output_dir):
      try:
         os.makedirs(output_dir)
      except OSError as exception:
         if exception.errno != errno.EEXIST:
            raise

   head, tail = os.path.split(input_file)
   base = os.path.splitext(tail)[0]
   output_fname="%sbin-%s.bed" %(bin_size,base)
   output_file = str(os.path.join(output_dir, output_fname))

   with open(output_file, 'w') as output_f:
      for line in bin_list:
         output_f.write(line)

class binThread (multiprocessing.Process):
   """
   Binning in threads
   """
   def __init__(self, lock, queue, bin_size, limits,  output_dir, format):
      self.lock = lock
      self.queue = queue
      self.bin_size = bin_size
      self.limits = limits 
      self.output_dir = output_dir
      self.format = format
      multiprocessing.Process.__init__(self)

   def run(self):
      while True:
         # Wait for data in task queue.
         self.lock.acquire()
         try:
            input_f = queue.get_nowait()
         except Queue.Empty:
            # finish
            return
         finally:
            self.lock.release()

         binit(bin_size = self.bin_size, limits = self.limits, format = self.format, 
               output_dir = self.output_dir, input_file = input_f)
         self.queue.task_done()


if __name__ == "__main__":

   # Build argument parser.
   parser = argparse.ArgumentParser(
         prog = 'binitBed.py',
         description = """ Binning the aligment file in 300bp(default bin size):
         - default format is sam
           - sam files obtained by gem-2-sam
         - optional format is in bed 
         - n: number of cores for multiprocessing
         !NOTE this program requires a big chunk of memory, the binning dumped directly into memory to speed up the binning!""",
         formatter_class=RawTextHelpFormatter
   )
   parser.add_argument(
         '-b',
         '--bin-size',
         metavar = 'n',
         type = int,
         nargs = '?',
         default = 300,
         help = 'bin size in base pairs'
   )
   parser.add_argument(
         '-l',
         '--limits',
         metavar = 'l',
         type = str,
         nargs = '?',
         default = 'limits_hg19',
         help = 'Chromosome size of ref.genome'
   )
   parser.add_argument(
         '-F',
         '--format',
         metavar = 'F',
         type = str,
         nargs = '?',
         default = 'sam',
         help = 'format of the input file'
   )
   parser.add_argument(
         '-n',
         '--n-threads',
         metavar = 't',
         type = int,
         nargs = '?',
         default = 1,
         help = 'number of threads to run in parallel'
   )
   parser.add_argument(
         '-od',
         '--output_dir',
         metavar = 'od',
         type = str,
         nargs = '?',
         default = '.',
         help = 'directory for the output file'
   )
   parser.add_argument(
         'input_file',
         metavar = 'f',
         type = str,
         nargs = '?',
         default = sys.stdin,
         help = 'file to process'
   )

   args = parser.parse_args()


   # bin with threads
   lock = multiprocessing.Lock()
   queue = multiprocessing.JoinableQueue(-1) #no.limit for queue
   manager = multiprocessing.Manager()


   # Fill in task queue while threads are running.
   for f_task in glob.glob(args.input_file):
      queue.put_nowait(f_task)

   # Create and start binning in threads.
   threads = [binThread(lock, queue, args.bin_size, args.limits, args.output_dir, args.format) for i in range(args.n_threads)]
   for thread in threads:
      thread.start()
   queue.join()
